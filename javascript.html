<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="./rescources/css/javascript.css">
    <link rel="stylesheet" href="./rescources/highlighting/prism.css">
    <script src="./rescources/highlighting/prism.js"></script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A Digital Notebook - Liam Brown">
    <meta name='author' content="Liam Brown-2022">
    <link rel="icon" href="./rescources/images/JS.png">
    <title>LB - Virtual Notebook For JavaScript</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Albert+Sans:wght@300;400;700&family=Source+Code+Pro:wght@300;400&display=swap" rel="stylesheet">
</head>

<body>
    <header>
        <section>
            <h1>Javascript Notebook. <br>Liam Brown</h1>
        </section>
    </header>
    <main>
        <nav id="pages">
            <ul>
                <li><a class="html" href="index.html">HTML</a></li>
                <li><a class="css" href="css.html">CSS</a></li>
                <li><a class= "javascript" href="javascript.html">Javascript</a></li>
                <li><a class="design" href="design.html">Design</a></li>
            </ul> 
        </nav>

        <nav id="topics">
            <ul>
                <li><a href="#syntax">Syntax</a></li>
                <li><a href="#arrays">Arrays</a></li>
                <li><a href="#loops">Loops</a></li>
                <li><a href="#objects">Objects</a></li>
                <li><a href="#higher-order-functions">Higher Order Functions</a></li>
                <li><a href="#iterators">Iterators</a></li>
                <li><a href="#dom">The DOM</a></li>
                <li><a href="#events">Events</a></li>
                <li><a href="#resources">Resources</a></li>
            </ul>
        </nav>


        <div>

            <article id="syntax">
                <h2>JS Syntax</h2>

                <h3>Comments</h3>
                <p>There are two types of code comment sin JS:</p>
                <ul>
                    <li><code class="language-js">//</code> -- A single line comment</li>
                    <li><code class="language-js">/* -- */</code> -- A multi line comment </li>
                </ul>

                <h3>String Interpolation</h3>
                    <p>In ES6, we can insert, or <emp>interpolate</emp>, variables into strings using <emp>template literals</emp>.</p>
                    <br>
                    <p>Things to note: </p>
                    <ul>
                       <li>a template literal is wrapped in backticks <code class="language-js"> ` </code></li>
                       <li>Inside a template literal, you'll see a placeholder, <code class="language-js">${example}</code>. The value of <code class="language-js">example</code> is insterted into the template literal</li>
                    </ul>

                    <p>Example: </p>
                    <pre><code class="language-js">const example-1 = "example";
    console.log(`This is an ${example-1}.`);
    // Output: This is an example.</code></pre>

                
                <h3>typeof Operator</h3>

                    <p>If you need to check a data type of a variable's value, you can use the <code class="language-js">typeof</code> operator.</p>
                    <p>The <code class="language-js">typeof</code> operator checks the value to its right and returns a string of the data type.</p>
                    
                    <br>
                    <pre><code class="language-js">const var1 = 'example';
console.log(typeof var1);
//Output: string</code></pre>



                <h3>Short-circuit evaluation</h3>

                    <p>While assigning a variable it is possible to give it a default value if the intentinal assignment is null</p>
                    <p>This is called a short-circuit evaluation, for example: </p>
                    <pre><code class=language-js>let username = '';
let defaultName = username || 'Stranger';

console.log(defaultName);
//Output: Stranger</code></pre>

                    <p>Because <code class="language-js">||</code> or statements check the left-hand condition first, the variable <code class="language-js">defaultName</code> will be asigned the actual value of <code class="language-js">username</code> if it is 'truthy', and it will be assigned the value of 'Stranger' if <code class="language-js">username</code> is 'falsy'.</p>



                <h3>Ternary Operator</h3>
                
                    <p>We can use a ternary operator to simplify an <code class="language-js">if...else</code> statement.</p>
                    <p>Take a look at the <code class="language-js">if...else</code> statement example: </p>
                    <pre><code class="language-js"> let isNightTime = true;
if (isNightTime) { 
    console.log('Turn on the lights!');
} else { 
    console.log('Turn off the lights!');
}</code></pre>

                    <p>We can use a ternary operator to perform the same functionality: </p>
                    <pre><code class="language-js">isNightTime ? console.log('Turn on the lights!') : 
console.log('Turn off the lights!');
                    </code></pre>

                    <p>In the example above: </p>
                    <ol>
                        <li>The condition, <code class="language-js">isNightTime</code>, is provided before the <code class="language-js"> ? </code>.</li>
                        <li>Two expressions follow the <code class="language-js"> ? </code> and are seperated by a colon <code class="language-js"> : </code>.</li>
                        <li>If the condisiton evalutes to true, the first expression executes</li>
                        <li>If the condisiton evalutes to false, the second expression executes</li>
                    </ol>
                    
                    <p>Like <code class="language-js">if...else</code> statements, ternary operators can be used for conditions which evaluate to true or false.</p>
            
                <h3>Switch Keyword</h3>
                    <p>A <code class="language-js">switch</code> statement provides an alternative syntax to <code class="language-js">else if </code> statements that are easier to read and write.</p>
                    <p>A <code class="language-js">switch</code> statements looks like this: </p>
                    <pre><code class="language-js">let groceryItem = 'papaya';
switch (groceryItem) {
    case 'tomato':
        console.log('Tomatoes are $0.49');
        break;
    case 'lime':
        console.log('Limes are $1.49');
        break;
    case 'papaya':
        console.log('Papayas are $1.29');
        break;
    default:
        console.log('Invalid item');
        break;
}
    
// Prints 'Papayas are $1.29'</code></pre>
            

                <h3>Function Expressions</h3>
                <p>Another way to define a function is to use a function expression. To define a function inside an expression, we can use the function keyword. In a function expression, the function name is usually omitted. A function with no name is called an anonymous function. A function expression is often stored in a variable in order to refer to it.</p>
                <img src="./rescources/images/FunctionExpression.png" alt="Image of a function expression">
                <p>To declare a function expression: </p>
                <ol>
                    <li>Declare a variable to make the variable's name be the name, or identifier, of your function. Since the release of ES6, it is common practice to use the <code class="language-js">const</code> as the ketword to declare the variable.</li>
                    <li>Assign as that variable's value an anonymous function created by using the function keyword followed by a set of parentheses with possible parameters. Then a set of curly braces that contain the function body.</li>
                </ol>
                <p>To invoke a function expression, write the name of the variable in which the function is stored followed by parentheses enclosing any arguments being passed into the function.</p>
                <code class="language-js">VariableName(argument1, argument2)</code>
                <p>Unlike function declarations, function expressions are not hoisted so they cannot be called before they are defined.</p>


                <h3>Arrow Functions</h3>

                    <p>ES6 introduced arrow function syntax, a shorter way to write functions by using the special "fat arrow" <code class="language-js">() =></code> notation.</p>
                    <br>
                    <p>Arrow functions remove the need to type out the keyword <code class="language-js">function</code> everytime you nede to create a function. Instead, you first include the parameters inside the <code class="language-js"> ( ) </code> and then add an arrow <code class="language-js"> => </code> that points to the function body surrounded in <code class="language-js"> { } </code> like this: </p>
                    <pre><code class="language-js">const rectangleArea = (width, height) => {
    let area = width * height;
    return area;
};</code></pre><br>

                <h3>Concise Body Arrow Functions</h3>
                <br>
                    <p>Javascript also provides several way to refactor arrow function syntax. The most condensed form of the function is known as concise body.</p>
                    <ol>
                        <li>Functions that take only a single paramter do not need that parameter to be encolsed in parentheses. However if a function takes zero or multiple parameteres, parentheses are required.
                            <br>
                            <p>ZERO PARAMETERS</p>
                            <code class="language-js">const functionName = () => {};</code>
                            <br>
                            <p>ONE PARAMETERS</p>
                            <code class="language-js">const functionName = paramOne => {};</code>
                            <br>
                            <p>TWO OR MORE PARAMETERS</p>
                            <code class="language-js">const functionName = (paramOne, paramTWO) => {};</code>
                            <br>
                        </li>
                        <li>A function body composed of a single-line block does not need curly braces. Wihtout the curly braces, whatever that line evalutes will be automatically returned. The contents of the block should immediately follow the arrow <code class="language-js">=></code> and the <code class="language-js">return</code> keyword is removed. This is referred to as <strong>implicit</strong> return
                            <p>SINGLE LINE BLOCK</p>
                            <code class="language-js"> const sumNumber = number => number + number;</code>
                            <br>
                            <p>MULTI LINE BLOCK</p>
                            <pre><code class="language-js"> const sumNumber = number => {
    const sum = number + number;
    return sum;
}</pre></code>
                        </li>
                    </ol>
            </article>

            <article id="arrays">
                <h2>Arrays</h2>

                <p>Arrays are declared very similarly to python. </p>
                <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">Full list of array methods (MDN)</a></p>
                <p>Here are some helpful things</p>

                    <h3>Built in methods</h3>

                    <h4>.length</h4>
                        <p><code class="language-js">.length</code> returns the number of items in an array. similarly to the string property</p>
                        <br>
                    <h4>.push()</h4>
                        <p><code class="language-js">.push()</code> adds item(s) to the end of an array. i.e .append</p>
                        <br>
                        <pre><code class='language-js'>example.push('item1', 'item2');
//Adds item1 and item2 to the end of example.</code></pre>
                    <h4>.pop()</h4>
                    <p><code class="language-js">.pop()</code> removes the last item of an array and returns it if called.</p>
                    <h4>.join()</h4>
                    <p></p>
                    <h4>.split()</h4>
                    <p></p>
                    <h4>.splice()</h4>
                    <p></p>
            </article>

            <article id="loops">
                <h2>Loops</h2>

                <h4>For...of</h4>
                <hr>
                <p>The ES6 version of JS introduced the shorter and more concise <code class="language-js">for..of</code> loop. This will outline the benifits of of suing the <code class="language-js">for..of</code> loops.</p>

                <h3>For loop vs for...of loop</h3>
                <p>Here is an example of iterating over each element in an array using a traditional for loop with an index variable: </p>
                <pre><code class="language-js">const hobbies = ['running', 'climbing', 'coding', 'writing']

for (let i = 0; i < hobbies.length; i++) { 
    console.log(`I enjoy ${hobbies[i]}).`);
}</code></pre>
                <p>And here is an example of iterating through the same array using a for...of loop: </p>
                <pre><code class="language-ls">const hobbies = ['running', 'climbing', 'coding', 'writing']

for (const hobby of hobbies) { 
    console.log(`I enjoy ${hobby}.`);
}</code></pre>

                <p>Both exmaple print out the same thing.</p>
                <ol>
                    <li>In the code snippet, we have hobbies, which is the array we want to itterate over.</li>
                    <li>The for...of loop specifies that we will iterate through the array and for each item in the array.</li>
                    <li>The variable hobby is assigned a different value on each iteration of the loop. The variable may be declared with the keywords: <code class="language-js">const</code>, <code class="language-js">let</code> or <code class="language-js">var</code>. You can name the variable anything but it is helpful to use a name related to the iterable object. In the example, notice the placeholder var uses the singular form of a plural array.</li>
                </ol>
                <p>There is no need to set up additional variables to store the an index with a for...of loop. The loop will iterate over each element in the iterable object and terminate itself when it reaches the last item. - so you don't need to track the number of items in the array. In the example an array was used but for...of loops also work with strings, sets, and other array-like objects.</p>
                <br>
                <p>Therefore, a for loop should be opted for if you need to access the indices or need finer control to determine what elements you want to loop over.</p>
                <br>
                <h3>Use Case: For loop vs for...of loop</h3>
                <p>The for...of loop is not a complete replacement for the for loop. For example: </p>
                <pre><code class="language-js">const nums = [1, 2, 3];
    
for (let i = nums.length - 1; i >= 0; i--) { 
    console.log(nums[i]);
}

console.log('Time is up!');</code></pre>
                <p>In this exmaple, itterating in reverse, you would not be able to use a for..of loop to complete this task. However, with a regular for loop, you have access to indices of the elements to determine a stopping condition and the ability to set a counter.</p>
            </article>

            <article id="objects">
                
                <h2>Objects</h2>


                <p>There are only seven fundamental data types in JavaScript, and six of those are the primitive data types: string, number, boolean, null, undefined, and symbol. With the seventh type, objects, we open our code to more complex possibilities. We can use JavaScript objects to model real-world things, like a basketball, or we can use objects to build the data structures that make the web possible.</p>
                <br>
                <p>At their core, JavaScript objects are containers storing related data and functionality, but that deceptively simple task is extremely powerful in practice.</p>
                <br>

                <h3>Creating Object Literals</h3>

                <p>Objects can be assigned to variables just like any JS type. We use curly braces to designate an object literal:</p>
                <p><code class="language-js">let exampleObject = {}</code></p>
                <p>We fill an object with unordered data. This data is organized into key-value pairs. A key is like a variable name that points to a location in memory that holds a value.</p>
                <br>
                <p>A key's value can be any data type in the language including functinos or other objects.</p>
                <p>We make a key-value pair by writing the key's name, or identifier, followed by a colon and then the value.We seperate each key-value pair in an object literal with a comma. Keys are strings, but when we have a key that does not have any special characters in it, Javascript allows us to omit the quotation marks.</p>
                <br>
                <pre><code class="language-js">let car = {
    'Fuel Type': 'diesel', 
    color: 'silver'
};</code></pre>

                <p>The car object has two properties Fuel Type and color. The 'Fuel Type' has quotation marks because it contains a space character.</p>
                <br>

                <h3>Accessing Properties</h3>

                <h4>Using Dot Notation</h4>
                <hr>
                <p>One way to access an object's property is using dot nation.</p>
                <pre><code class="language-js">'hello'.length; // Returns 5</code></pre>
                <p>With property dot notation, we write the objects name, followed by the dot operator and then the property name (key: </p>

                <pre><code class="language-js">let car = { 
    home: 'Swansea', 
    color: 'Red'
};
car.home; // Returns 'Swansea'
car.color; // Returns 'Red'</code></pre>

                <p>If we try to access a property that does not exist on that object, <code class="language-js">undefined</code> will be returned.</p>
                <br>

                <h4>Bracket Notation</h4>
                <hr>
                <p>Another way to access a key's value is by using bracket notation.</p>
                <p>Similarly as to when indexing an array: </p>
                <pre><code class="language-js">['a', 'b', 'c'][0]; //returns a;</code></pre>
                <p>To use bracket notation to access an object's property, we pass in the property name (key) as a string.</p>
                <br>
                <p>We <strong>must</strong> use bracket notation when accessing keys that have numbers, spaces, or special characters in them. Without bracket notation in these situations, our code would through an error.</p>
                <pre><code class="language-js">let spaceship = {
    'Fuel Type': 'Turbo Fuel',
    'Active Duty': true,
    homePlanet: 'Earth',
    numCrew: 5
};
spaceship['Active Duty'];   // Returns true
spaceship['Fuel Type'];   // Returns  'Turbo Fuel'
spaceship['numCrew'];   // Returns 5
spaceship['!!!!!!!!!!!!!!!'];   // Returns undefined</code></pre>
                <p>With bracket notation you can also use a variable inside the brackets to select the keys of an object. This can be especially helpful when working with functions: </p>
<pre><code class="language-js">let returnAnyProp = (objectName, propName) => objectName[propName];

returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'</code></pre>

                <p>If we tried to write this function with dot notation ( objectName.propName ) the computer would look for a key of 'propName' on our object and not the value of the propName paramater.</p>

                <h4>Property Assignment</h4>
                <hr>
                <p>Objects are mutable, we can use dot notation, or bracket notation and the assignment operator to add new key-value pairs to an object or change an existing property.</p>

                <pre><code class="language-js">car['Fuel Type'] = 'Electric';
car.color = 'gold';</code></pre>

                <p>One of two things can happen with property assignment: </p>
                <ol>
                    <li>If the property already exists on the object, whatever value it held before will be replaced with the newly assigned value.</li>
                    <li>If there was no property with that name, a new property will be added to that object.</li>
                </ol>

                <aside><strong>Note: </strong> It is important to know that although we can't reassign an object declared <code class="language-js">const</code>, we can still mutate it, meaning we can add new properties and change the properties that are there.</aside>

                <h4>Methods</h4>
                <hr>
                <p>When the data stored on an object is a function we call that a method. A property is what an object has, while a method is what an object does.</p>
                <br>
                <p>We can include methods in our object literals by creating ordinary, comma-seperated key-value pairs. The key serves as our method's name, while the value is an anonymoous function expression.</p>
                <pre><code class="language-js">const alienShip = { 
    invade: function() { 
        console.log("Hello! We have come to dominate your planet!");
    }
};</code></pre>
                <p>With the new method syntax introduced in ES6 we can omit the colon and the function keyword: </p>
                <pre><code class="language-js">const alienShip = { 
    invade () { 
        console.log("Hello! We have come to dominate your planet!");
    }
};</code></pre>


                <h4>Nested Objects</h4>
                <hr>
                <p>In application code, objects are often nested -- an object might have another object as a property which in turn could have a property that's an array of even more objects!</p>
                <br>
                <p>Imagine an object for a spaceship, we want a crew object. This will contain all the crew members who do important work on the craft. Each of those crew members are objects themselves. They have properties like name and degree, and they each have unique methods based on their roles. We can also nest other objects in the spaceship object such as a telescope or nest detaisl about the spaceship's computer inside a parent of nanoelectronics objects</p>

<pre><code class="language-js">const spaceship = {
    telescope: {
       yearBuilt: 2018,
       model: '91031-XLT',
       focalLength: 2032 
    },
   crew: {
       captain: { 
           name: 'Sandra', 
           degree: 'Computer Engineering', 
           encourageTeam() { console.log('We got this!') } 
        }
   },
   engine: {
       model: 'Nimbus2000'
    },
    nanoelectronics: {
        computer: {
           terabytes: 100,
           monitors: 'HD'
        },
       'back-up': {
          battery: 'Lithium',
          terabytes: 50
        }
   }
}; </code></pre>
                    <p>We can chain propertors to access nested properties. We'll have to pay attention to which operator makes sense to use in each layer.</p>
<pre><code class="language-js">spaceship.nanoelectronics['back-up'].battery;
// Returns 'Lithium'</code></pre>

                    <h4>Pass By Reference</h4>
                    <hr>
                    <p>Objects are passed by reference. This means when we pass a variable assigned to an object into a function as an argument, the computer inerprets the parameter name as pointing to the space in memory holding that object. As a result, functions which change object properties actually mutate the object permanently (even when the object is assigned to a const variable)</p>

<pre><code class="language-js">const spaceship = {
    homePlanet : 'Earth',
    color : 'silver'
};

    let paintIt = obj => {
    obj.color = 'glorious gold'
};

paintIt(spaceship);

spaceship.color // Returns 'glorious gold'</code></pre>

                    <p>The function paintIt() permanently changed the color of the spaceship object. However reassignment of the spaceship variable wouln't work the same way: </p>

<pre><code class="language-js">let spaceship = {
    homePlanet : 'Earth',
    color : 'red'
};
let tryReassignment = obj => {
    obj = {
        identified : false, 
        'transport type' : 'flying'
}
console.log(obj) // Prints {'identified': false, 'transport type': 'flying'}
   
  };
  tryReassignment(spaceship) // The attempt at reassignment does not work.
  spaceship // Still returns {homePlanet : 'Earth', color : 'red'};
   
  spaceship = {
    identified : false, 
    'transport type': 'flying'
  }; // Regular reassignment still works.</code></pre>

                    <ul>
                        <li>Spaceship object is declared with let. This allows it to reassign to a new object with identified and 'transport type' properties with no issues.</li>
                        <li>When tried reassign using a function, the reassignment didn't stick.</li>
                        <li>When spaceship is passed in the function, obj became a refernece to the memory location of the spaceship object, but <strong>not</strong> to the spaceship variable. This is because the obj parameter of the tryReassignment() function is a variable in its own right. The body of tryReassignment() has no knowledge of the spaceship variable.</li>
                        <li>While reassigning in the body of tryReassignment(), the obj variable came to refer to the memory location of the object, while the spaceship variable was completely unchanged from its earlier value.</li>
                    </ul>


                    <h4>Looping Through Objects</h4>
                    <hr>
                    <p>Javascript has given us an alternative solution for iterating through objects with the for...in syntax.</p>
                    
                    <aside><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#iterating_over_own_properties_only">MDN Docs for for...in</a></aside>

                    <p>for...in will execute a given block of code for each property in an object.</p>

<pre><code class="language-js">let spaceship = { 
    crew: {
        captain: { 
          name: 'Lily', 
        },
        'chief officer': { 
          name: 'Dan', 
        },
        medic: { 
          name: 'Clementine', 
        }
      }
    }; 
     
    // for...in
    for (let crewMember in spaceship.crew) {
      console.log(`${crewMember}: ${spaceship.crew[crewMember].name}`);
    }
</code></pre>
                    <p>Here, the for...in loop will iterate through each element of spaceship.crew, in each iteration, the variable crewMember is set to on of spaceship.crew's keys, enabling us to log a list of crew members' role and name.</p>

                    <h4>Arrow functions and 'this' keyword</h4>
                    <hr>
                    <p>If we use the this keyword in a method, then the value of this is the calling object. However, it becomes a bit more complicated when we start using arrow functions.</p>
                    <br>
                    <p>Arrow functions inherently bind, or tie an already defined this value to the function itself that is NOT the calling object. </p>
                    <br>
                    <p>In other words, try to avoid using this keyword in an arrow function as it in turn calls for a global object with a value of this, not the calling object itself.</p>

                    <h4>Privacy</h4>
                    <hr>
                    <p>Certain languages have privacy built-in for objects, but JavaScript does not have this feature. Rather, JavaScript developers follow naming conventions that signal to other developers how to interact with a property. One common convention is to place an underscore <code class="language-js">_</code> before the name of a property to mean that the property should not be altered. For example: </p>
<pre><code class="language-js">const bankAccount = { 
    _amount: 1000
}</code></pre>
                    <p>That being said, even with the underscore the property is still able to be reassigned.</p>

                    <h4>Setters and Getters</h4>
                    <hr>
                    <h4>Getters</h4>
                    <p>Getters are methods that get and return the internal properties of an object But they can do more than just retrieve the value of a property!</p>
                    <p>Example of a getter method: </p>
<pre><code class="language-js">const person = {
    _firstName: 'John',
    _lastName: 'Doe',
    get fullName() {
      if (this._firstName && this._lastName){
        return `${this._firstName} ${this._lastName}`;
      } else {
        return 'Missing a first name or a last name.';
      }
    }
  }
   
// To call the getter method: 
person.fullName; // 'John Doe'</code></pre>
                    <p>Notice that in the getter method above: </p>
                    <ul>
                        <li>We use the <code class="language-js">get</code> keyword followed by a function.</li>
                        <li>We use an <code class="language-js">if...else</code> conditional to check if both <code class="language-js">_firstName</code> and <code class="language-js">_lastName</code> exist (by making sure they both return truthy values) and then return a different value depending on the result.</li>
                        <li>We can access the calling object's internal properties using <code class="language-js">this</code>. In <code class="language-js">fullName</code>, we're accessing both <code class="language-js">this._firstName</code> and <code class="language-js">this._lastName</code></li>
                        <li>In the last line we call <code class="language-js">fullName</code> on <code class="language-js">person</code>. In general, getter methods do not need to be called witha  set of parentheses. Syntactically, it looks like we're accessing a property.</li>
                    </ul>
                    <p>Advantages of using getter methods: </p>
                    <ul>
                        <li>Getters can perform an action on the data when getting a property.</li>
                        <li>Getters can return different values using conditionals</li>
                        <li>In a getter, we can access the properties of the calling object using this</li>
                        <li>Then functionality of our code is easier for other developers to understand</li>
                    </ul>

                    <p>Another thing to keep in mind when using getter (and setter) methods is that properties cannot share the same name as the getter/setter function. If we do so, then calling the method will result in an infinite call stack error. One workaround is to add an underscore before the property name like in the example above.</p>

                    <h4>Setters</h4>
                    <p>Along with getter methods, we can also create setter methods which reassign values of existing properties within an object. For example: </p>
<pre><code class="language-js">const person = { 
    _age: 37,
    set age(newAge){
        if (typeof newAge === 'number'){
            this._age = newAge;
        } else { 
            console.log('You must assign a number to age');
        }
    }
</code></pre>
                    <p>Notice that in the example above: </p>
                    <ul>
                        <li>We can perform a check for what value is being assigned to <code class="language-js">this._age</code></li>
                        <li>When we use the setter method, only values that are numbers will reassign <code class="language-js">this._age</code></li>
                        <li>There are different outputs depending on what values are used to reassign <code class="language-js">this._age</code></li>
                    </ul>
                    <p>Then to use the setter method: </p>
<pre><code class="language-js">person.age = 40;
console.log(person._age); // Logs: 40;
person.age = '40'; //Logs you must assign a number to age
</code></pre>
                    <p>Setter methods like <code class="language-js">age</code> do not need to be called with a set of parentheses. Syntactically, it looks like we're reassigning the value of a property.</p>
                    <br>
                    <p>Like getter methods, there are similar advantages to using setter methods that include checking input, performing actions on properties, and displaying a clear intention of how the object is supposed to be used. Nonetheless, even with a setter method, it is still possible to directly reasign properties. For example, in the example above, we can still set <code class="language-js">._age</code> directly: </p>
<pre><code class="language-js">person._age = 'forty-five'
console.log(person._age)l // Prints forty-five
</code></pre>

                <h3>Factory Functions</h3>

                <p>Factory functions is a function that returns an object and can be reused to make multiple object instances. Factory functions can also have parameters allowing us to custoize the object that gets returned.</p>

                <p>For example, if we were to create an objcet to represent monsters in Javascript. There are many different types of monsters and we could go about making each monster individually but we can also use a factory function to make our lives easier.</p>
<pre><code class="language-js">const monsterFactory = (name, age, energySource, catchPhrase) => { 
    return { 
        name: name,
        age: age,
        energySource: energySource,
        scare() { 
            console.log(catchPhrase);
        }
    }
};
</code></pre>
                <p> We ca call <code class="language-js">monsterFactory</code> with the necessary arguments and assign the return value to a variable: </p>
<pre><code class="language-js">const ghost = monsterFactory('Ghouly, 251, 'ectoplasm', 'BOO!');  
ghost.scare(); // Returns: 'BOO!'
</code></pre>
                <p>Now we have a <code class="language-js">ghost</code> object as a result of calling <code class="language-js">monsterFactory()</code> with the needed arguments. With this in place, we woudlnt' have to create an object literal every time a new monster was needed.</p>

                <h4>Property Value Shorthand</h4>
                <hr>
                <p>ES6 introduced a shortcut for assigning properties to variables knows as destructuring.</p>

                <p>We can use a destructuring technique, called property value shorthand to save some time and keystrokes when creating factory functions: </p>
<pre><code class="language-js">const monsterFactory = (name, age) => { 
    return { 
        name, 
        age
    }
</code></pre>

                <h4>Descructured Assignment</h4>
                <hr>
                <p>Often we want to extract key-value pairs from objects and save them as variables. Take for example the following object: </p>
<pre><code class="language-js">const robot = {
    model: '1E78V2',
    energyLevel: 100,
    functionality: {
      beep() {
        console.log('Beep Boop');
      },
      fireLaser() {
        console.log('Pew Pew');
      },
    }
};
</code></pre>
                <p>If we wanted to extract the <code class="language-js">model</code> property as a variable, we could use the following code: </p>
<pre><code class="language-js">const model = robot.model;
console.log(model) // prints '1E78V2'
</code></pre>
                <p>However, we can also take advantage of a destructuring technique called desctructured assignment to save ourselves some key strokes. In desctructured assignment we create a variable with the name of an object's key that is wrapped in curly braces <code class="language-js"> { } </code> and assign to it the object. For example: </p>
<pre><code class="language-js">const { model } = robot;
console.log(model); // Prints '1E78V2' </code></pre>
                <aside><strong>Note: </strong> We can even use desctructured assignment to grab nested properties or functions from an object: </aside>
<pre><code class="language-js">const { functionality } = robot;
functionality.beep(); // outputs 'Beep Boop'
</code></pre>

                <h4>Built-in Object Methods</h4>
                <hr>
                <p>Objects also have their own built-in methods, for example we have access to object instance methods like: <code class="language-js">.hasOwnProperty()</code>, <code class="language-js">valueOf()</code> and loads more, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Methods">MDN object docs</a></p>
            </article>

            <article id="higher-order-functions"> 

                <h2>Higher-Order Functions</h2>
                    <p>Since functions can behave like any other type of data in Javascript. Therefore functions can accept other functions as parameters. A Higher-order function is a function that either accepts functions as parameters, returns a function, or both.</p>
                    <p>Functions that get passed in as parameters are called callback functions. Callback functions get invoked during the execution of the higher-order function.</p>
                    <br>
                    <p>When invoking a higher-order function, and pass another function in as an arguemnt, we don't invoke the argument function. Invoking it would evaluate to passing in the return value of that function call. With callback functions, we pass in the function itself by typing the function name <strong>without</strong> parentheses: </p>
<pre><code class="language-js">const higherOrderFunc = param => { 
    param();
    return `I just invoked ${param.name} as a callback function!`
}

const anotherFunc = () => { 
    return "I'm being invoked by the higher-order function!";
}

higherOrderFunc(anotherFunc);
</code></pre>

                <aside>We could also invoke a higher-order function with an anonymous function. For example: Here is one that invokes an anonymous function that counts to 10.</aside>
<pre><code class="language-js">higherOrderFunction(() => { 
    for (let i = 0; i <= 10; 1++){
        console.log(i);
    }
});</code></pre>
            </article>

            <article id="iterators">

                <h2>Iterators</h2>

                    <p>One tool for iterating is a <code class="language-js">for</code> loop. However, we also have access to built-in array methods which make looping easier.</p>
                    <p>The built-in JavaScript array methods that help us iterate are called <strong>iteration methods</strong>, at times reffered to as iterators. Iterators are methods called on arrays to manipulate elements and return values. </p>
                
                <h3>The .ForEach() Method</h3>

                    <p>Aptly named, .forEach() will excecute the same code for each element of an array.</p>

<pre><code class="language-js">const groceries = ['brown sugar', 'salt', 'cranberries'];

groceries.forEach(function(groceryItem) { 
    console,log(' - ' + groceryItem);
});</code></pre>
                    <p>The code above will log a nicely formatted list of the groceries to the console. Here is an explanation of the syntax invoking <code class="language-js">.forEach()</code></p>
                    <ul>
                        <li><code class="language-js">groceries.forEach()</code> calls the <code class="language-js">forEach</code> method on the groceries array</li>
                        <li><code class="language-js">.forEach()</code> takes an argument of callback function.</li>
                        <li><code class="language-js">.forEach()</code> loops through the array and executes the callback function for each element. During the execution, the current element i passed as an argument to the callback function.</li>
                        <li>The return value for <code class="language-js">.forEach()</code> will always be undefined.</li>
                    </ul>
                    <br>
                    <aside>Another way to pass a callback for <code class="language-js">.forEach()</code> is to use arrow function syntax.</aside>
<pre><code class="language-js">groceries.forEach(groceryItem => console.log(groceryItem));</code></pre>
                    <p>We can also define a function beforehand to be used as the callback function</p>
<pre><code class="language-js">function printGrocery(element) { 
    console.log(element);
}

groceries.forEach(printGrocery);
</code></pre>
                <hr>
                <br>
                <h3>The .map() Method</h3>

                <p>When <code class="language-js">.map()</code> is called on an array, it takes an argument of a callback function and reutrns a new array. For example: </p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4, 5];

const bigNumbers = numbers.map(number => { 
    return number * 10;
})
</code></pre>
                <p><code class="language-js">.map()</code> works in a similar manner to <code class="language-js">.forEach()</code> -- The major difference is that <code class="language-js">.map()</code> returns a new array.</p>

                <p>In the example above: </p>
                <ol>
                    <li><code class="language-js">numbers</code> is an array of numbers</li>
                    <li><code class="language-js">bigNumbers</code> will store the return value of calling <code class="language-js">.map()</code> on <code class="language-js">numbers</code></li>
                    <li><code class="language-js">numbers.map</code> will iterate through each element in the <code class="language-js">numbers</code> array and pass the element into the callback function</li>
                    <li><code class="language-js">return number * 10</code> is the code we wish to execute upon each element in the array.</li>
                </ol>
                <hr>
                <br>

                <h3>The .filter() method</h3>

                <p>Like <code class="language-js">.map()</code>, <code class="language-js">.filter()</code> returns an array of elements after filtering out certain elements from the original array. The callback function for <code class="language-js">.filter()</code> method should return true or false depending on the element that is passed to it. The elements that cause the callback function to return true are added to the new array.</p>
                <p>For example: </p>
<pre><code class="language-js">const words= ['chair', 'music', 'pillow', 'brick'];
    
const shortWords = words.filter(word => { 
    return word.length < 6;
})
</code></pre>
                <ul>
                    <li><code class="language-js">words</code> is an array of strings</li>
                    <li><code class="language-js">const shortWords = </code> delclares a new variable that will store the returned array from invoking <code class="language-js">.filter()</code></li>
                    <li>The callback function is an arrow function that has a single parameter, <code class="language-js">word</code>. Each element in the words array will be passed to this function as an argument</li>
                    <li><code class="language-js">words.length < 6 </code> is the condition in the callback function. Any word from words array that has fewer than 6 characters will be added to the shortWords array.</li>
                </ul>

                <aside><strong>Note: </strong>Observe how <code class="language-js">words</code> was not mutated, and <code class="language-js">shortWords is a new array.</code></aside>
                <hr>
                <br>

                <h3>The .findIndex() Method</h3>

                <p>Calling <code class="language-js">.findIndex()</code> on an array will return the index of the first element that evaluates to tru in the callback function</p>
<pre><code class="language-js">const jumbledNums = [123, 25, 78, 5, 9];

const lessThanTen = jumbledNums.findIndex(num => { 
    return num < 10;
})
</code></pre>

                <ul>
                    <li><code class="language-js">jumbledNums</code> is an array that contains elements that are numbers</li>
                    <li><code class="language-js">const lessThanTen = </code> declares a new variable that stores the returned index number from invoking <code class="language-js">.findIndex()</code></li>
                    <li>The callback function is an arrow function that has a single paramter, num. Each element in the <code class="language-js">jumbledNums</code> array will be passed to this function as an argument</li>
                    <li><code class="language-js">num < 10;</code> is the condition that elements are checked against. <code class="language-js">.findIndex()</code> will return the index of the first element which evaluates to true for that condition.</li>
                </ul>

                <aside>If there isn't a single element in the array that satisfies the condition in the callback, then <code class="language-js">.findIndex()</code> will return -1.</aside>
                <hr>
                <br>

                <h3>The .reduce() Method</h3>

                <p>The <code class="language-js">.reduce()</code> method returns a single value after iterating through the elements of an array, thereby <strong>reducing</strong> the array. Take a look at the example below: </p>
<pre><code class="language-js">const numbers = [1, 2, 4, 10];

const summedNums = numbers.reduce((accumulator, currentValue) => { 
    return accumulator + currentValue; 
})
</code></pre>
                <br>
                <aside>Here are the values of <code class="language-js">accumulator</code> and <code class="language-js">currentValue</code> as we iterate through the <code class="language-js">numbers</code> array: </aside>
                <table>
                    <tr>
                    <th>Iteration</th>
                    <th><code class="language-js">accumulator</code></th>
                    <th><code class="language-js">currentValue</code></th>
                    <th>return value</th>
                    </tr>
                    <tr>
                        <td>First</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>Second</td>
                        <td>3</td>
                        <td>4</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td>Third</td>
                        <td>7</td>
                        <td>10</td>
                        <td>17</td>
                    </tr>
                </table>
                <br>

                <ul>
                    <li><code class="language-js">numbers</code> is an array that contains numbers</li>
                    <li><code class="language-js">summedNums</code> is a variable that stores the returned value of invoking <code class="language-js">.reduce()</code></li>
                    <li>The callback function has two paramters, <code class="language-js">accumulator</code> and <code class="language-js">currentValue</code>. The value of accumulator starts off as the value of the first element in the array and the currentValue starts as the second element.</li>
                    <li>As <code class="language-js">.reduce()</code> iterates through the array, the return callback function becomes the <code class="language-js">accumulator</code> value for the next iteration, <code class="language-js">currentValue</code> takes on the value of the current element in the looping process</li>
                </ul>

                <aside>The <code class="language-js">.reduce()</code> method can also take an optional second paramter to set an inital value for <code class="language-js">accumulator</code> (remember, the first argument is the callback function). For instance: </aside>
<pre><code class="language-js">const numbers = [1, 2, 4, 10];

const summedNums = numbers.reduce((accumulator, currentValue) => { 
    return accumulator + currentValue
}, 100) // <- Second arguemnt for .reduce()

console.log(summedNums); // Output: 117 - as apposed to 17.
</code></pre>
            <br>
            <p>Here's an updated chart that accounts for the second argument of 100: </p>
            <table>
                <tr>
                    <th>Iteration #</th>
                    <th><code class="language-js">accumulator</code></th>
                    <th><code class="language-js">currentValue</code></th>
                    <th>return value</th>
                </tr>
                <tr>
                    <td>First</td>
                    <td>100</td>
                    <td>1</td>
                    <td>101</td>
                </tr>
                <tr>
                    <td>Second</td>
                    <td>101</td>
                    <td>2</td>
                    <td>103</td>
                </tr>
                <tr>
                    <td>Third</td>
                    <td>103</td>
                    <td>4</td>
                    <td>107</td>
                </tr>
                <tr>
                    <td>Fourth</td>
                    <td>107</td>
                    <td>10</td>
                    <td>117</td>
                </tr>
            </table>

            <br>
            <li class="bookmark">
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods" target="_blank">
                    <h3>MDN's Array iteration methods page</h3>
                </a>
            </li>
            </article>

            <article id="dom">
                
                <h2>The DOM ( <strong>D</strong>ocument <strong>O</strong>bject <strong>M</strong>odel )</h2>

                <p>The <code class="language-js">document</code> object in JavaScript is the door to the DOM structure. The <code class="language-js">document</code> allows you to access the root node of the DOM tree. Before you can access a specific element in the page, first you must access the document structure itself. The <code class="language-js">document</code> object allows scripts to access children of the DOM as properties</p>

                <p>For example, if you want to access the <code class="language-js">&lt;body&gt;</code> element from your script, you can access it as a property of the document object by using <code class="language-js">document.body</code>. This property will return the body element of the DOM.</p>

                <aside><a href=https://developer.mozilla.org/en-US/docs/Web/API/Document target="_blank">List of all document properties</a></aside>

                <h3>The .innerHTML property</h3>

                <p><code class="language-js">.innerHTML</code> property allows you to access and set the contents of an element.</p>
                <p>Heres how you would reassign the contents of the <code class="language-js">&lt;body&gt;</code> elemenet</p>
<pre><code class="language-js">document.body.innerHTML = 'This is an example.';</code></pre>
                <br>
                <p>The <code class="language-js">.innerHTML</code> property can also add any valid HTML elements. The following example replaces the contents of the body element by assiging a h2 element as a child inside the body element: </p>
<pre><code class="language-js">document.body.innerHTML = '&lt;h2&gt;This is now a heading!&lt;/h2&gt;'</code></pre>
                <hr>
                <br>

                <h3>Selecting and Modifying Elements</h3>
                <p>The DOM interface allows us to access a specific element with CSS selectors.</p>
                <p>CSS selectors can include a tag name, class or ID</p>
                <br>
                <p>The <code class="language-js">.querySelector()</code> method allows us to specify a CSS selector as a string and returns the first element that matches that selector. The following code would return the first paragraph in the document</p>

<pre><code class="language-js">document.querySelector('p');</code> </pre>

                <p>Along with <code class="language-js">.querySelector()</code>, JavaScript has more targeted methods that select elements based on their class, id or tag name</p>
                <br>
                <p>For example, if you want to access an element directly by its ID, you can use the aply named <code class="language-js">.getElementByID()</code> method: </p>
<pre><code class="language-js">document.getElementByID('bio').innerHTML = 'New description';</code></pre>
                <p>There is also the <code class="language-js">.getElementsByClassName()</code> and <code class="language-js">.getElementsByTagName()</code> which return an array of elements, instead of just one element. You can use bracket notation to access individual elements of an array: </p>

<pre><code class="language-js">// Set first element of .student class as 'Not yet registered
document.getElementsByClassName('student')[0].innerHTML = 'Not Yet Registered';

// Set second &lt;li&gt; tag as 'John Doe'
document.getElementsByTagName('li')[1].innerHTML = 'John Doe';
</code></pre>
<br>

<li class="bookmark">
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods" target="_blank">
        <h3>MDN's Document object model docs</h3>
        <p>List of all DOM interfaces</p>
    </a>
</li>
                <hr>
                <br>
                <h3>Styling Elements</h3>

                <p>The <code class="language-js">.style</code> property of a DOM element provides access to the inline style of that HTML tag.</p>

                <p>The syntax follows an <code class="language-js">element.style.property</code> format, with the property representing a CSS property. For example, the following code selects the first element with a class of blue and assigns blue as the background-color: </p>
                
<pre><code class="language-js">let blueElement = document.querySelector('.blue')
blueElement.style.backgroundColor = 'blue';
</code></pre>

                <aside>Unlike CSS the DOM <code class="language-js">.style</code> property does not implement a hyphen as such as <code class="language-js">background-color</code>. Check out this <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#index" target="_blank">MDN regference page</a> to see a list of how CSS properties are converted into JavaScript</aside>
                <hr>
                <br>

                <h3>Traversing the DOM</h3>

                <p>Each element has a <code class="language-js">.parentNode</code> and <code class="language-js">.children</code> property. The .parentNode property returns returns the parent of the specified element in the DOM hierachy.</p>
                
                <aside><strong>Note: </strong> that the <code class="language-js">document</code> element is the root node so its .parentNode property will return <code class="language-js">null</code>. The <code class="language-js">.children</code> property returns an array of the specified element's children and if that element has no children, it also wil return <code class="language-js">null</code></aside>
                <hr>
                <br>

                <h3>Creating and Inserting Elements</h3>

                <p>Just as the DOM allows scripts to modify existing elements, it also allows for the creation of new ones.</p>
                <br>
                <p>The <code class="language-js">.createElement()</code> method creates a new element based on the specified tag name passed into it as an argument. However, it does not append it to the document. It creates an empty element with no inner HTML</p>
                <br>
<pre><code class="language-js">let paragraph = document.createElement('p')</code></pre>
                <p>Here, the .createElement() method takes 'p' as its argument which creates an empty p element and stores it as the paragraph variable.</p>
                <br>
                <p>We can then assign values to the properties of the newly created elements: </p>
<pre><code class="language-js">paragraph.id = 'info';
paragraph.innerHTML = 'The text inside the paragraph';
</code></pre>

                <p>In order to create an element and add it tot eh the web page, you must assign it to be the child of an element that already exists on the DOM, referred to as the parent element. We call this process <strong>appending</strong>The <code class="language-js">.appendChild()</Code> mehod will add the a child element as the parent element's last child node.</p>
                <p>The following code appends the p element stored in paragraph variable to the document body.</p>
<pre><code class="language-js">document.body.appendChild(paragraph)</code></pre>
                <p>The <code class="language-js">.appendChild()</code> method does not replace the content inside of the parent, in this case, body. Rather, it appends the new element as the last child of that parent.</p>
                <hr>
                <br>

                <h3>Remove an Element</h3>

                <p>The DOM allows allows for the removal of an element. The <code class="language-js">.removeChild()</code> method removes a specified child from a parent.</p>
<pre><code class="language-js">let paragraph = document.querySelector('p');
document.body.removeChild(paragraph);
</code></pre>
                <p>In the above example code, the .querySelector() method reutrns the first paragraph in the document. Then, the paragraph element is passed as an argument of the .removeChild() method chained to the parent of the paragraph -- document.body. this removes the first paragraph from the document body.</p>

                <p>If you want to hide an element rather than completely delete it, the <code class="language-js">.hidden</code> property allows you to hide it by setting the property to false.</p>

<pre><code class="language-js">document.getElementById('sign').hidden = true;</code></pre>

                <aside>Note: Using .hidden over display = none; removes it from view from screen readers where display = none does not</aside>
            </article>


            <article id="events">

                <h2>Events</h2>

                <p>Events on the web are user interactions and browser manipulations that you can program to trigger functionality. I.E: </p>

                <ul>
                    <li>A mouse clicking a button</li>
                    <li>Webpage files loading in the browser</li>
                    <li>A user swiping right on an image</li>
                </ul>

                <p>When a user does any of the above actions, they're causing the event to be fired or be triggered.</p>

                <h3>Event Handler Registration</h3>
                <p>Using <code class="language-js">.addEventListener()</code> method, we can have a DOM element listen for a specific event and execute a block of code when the event is detected. The DOM element that listens for an event is called the event target and the block of code that runs when the event happens is called the event handler</p>
                <pre><code class="language-js">let eventTarget = document.getElementById('targetElement');

eventTarget.addEventListener('click', function() }{ 
    // this block of code will run when click event happens on eventTarget element.
});</code></pre>

            <aside>Instead of using an anonymoous function as the event handler, its best practice to create a named event handler function. This will keep code organized and reusable.</aside>
            <br>
            <p>Event Handlers can also be registered by setting an <code class="language-js">.onevent</code> property on a DOM element (event target). The pattern for registering a specific event is to append an element with .on followed by the lowercased event type name. For instance, if we want to register a click event with this pattern: </p>
<pre><code class="language-js">eventTarget.onclick = eventHandlerFunction; </code></pre>

            <p>It is important to know that this <code class="language-js">.onevent</code> property and <code class="language-js">.addEventListener()</code> will both register event listeners. With <code class="language-js">.onevent</code>, it allows for one event handler function to be attached to the event target. However, with <code class="language-js">.addEventListener()</code> method, we can add multiple event handler functions.</p>

            <h3>Removing Event Listeners</h3>

            <p>The <code class="language-js">.removeEventListener()</code> method is used to reverse the <code class="language-js">.addEventListener()</code> method. This method stops the event target from 'listening' for an event to fire when it no longer needs to.</p>
            <p><code class="language-js">.removeEventListener()</code> takes two arguements</p>
            <ol>
                <li>The event type as a string</li>
                <li>The event handler function</li>
            </ol>
            <p>For example: </p>
<pre><code class="language-js">eventTarget.removeEventListener('click', eventHandlerFunction);</code></pre>
            
            <p>Because there can be multiple event handler functions associated with a particular evewnt, this method needs both the exact event type name and the name of the event handler you want to remove.</p>
            <aside><strong>Note: </strong> <code class="language-js">.addEventListener()</code> was provided an anonymous function, then that event listener cannot be removed.</aside>
            <hr>
            <br>


            <h3>Event Object Properties</h3>

            <p>Javacript stores events as Event Objects with their related data and functionalties as properties and methods. When an event is triggeredm the event object can be passed as an argument to the event handler function.</p>
<pre><code class="language-js">functino eventHandlerFunction(event){ 
    console.log(event.timeStamp);
}

eventTarget.addEventListener('click', eventHandlerFunction);
</code></pre>
    <aside><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">MDN page for JS event objects</a></aside>

            <p>In the example above, when the 'click' event is triggered on the eventTarget, the eventHandlerFunction recieves event, the Event object, which has information related to the 'click' event. Then, it logs the time it took for event to be triggered since the document was loaded by accessing the <code>.timeStamp</code> property of the event object </p>
            <br>
            <p>There are pre-determined properties associated with event objects. You can call these properties to see information about the event, for example: </p>
            <ul>
                <li><code>.target</code> to reference the elemnt that the event is registered to. </li>
                <li><code>.type</code> to access the name of the event.</li>
                <li><code>.timeStamp</code> to access the number of milliseconds that passed since the document loaded and the event was triggered.</li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">MDN event page</a></li>
            </ul>

            <hr>
            <br>

            <h3>Event Types</h3>

            <p>It is important to know most events in the DOM take place without being noticed because there are no event handlers connected to them. </p>
            <li class="bookmark">
                <a href="https://developer.mozilla.org/en-US/docs/Web/Events">MDN Events reference</a>
                <p>A list of events that can be handled</p>
            </li>
            

            </article>

            <article id="resources">
                <li class="bookmark">
                    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" >
                        <h3> MDN docs for Javascript </h3>
                        <p> List of all helpful info on JS from Mozilla</p>
                    </a>
                <li class="bookmark">
                    <a href="https://www.codecademy.com/resources/docs/javascript" target="_blank" >
                        <h3> Codecademy docs for Javascript </h3>
                        <p> List of all helpful info on JS from Codecademy</p>
                    </a>
            </article>

        </div>
    </main>

    <footer>
        <p>Designed by Liam Brown. For Liam Brown</p>
    </footer>

    
</body>
</html>